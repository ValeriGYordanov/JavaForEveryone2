package last.project.javaforeveryone.model;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import java.util.ArrayList;

import last.project.javaforeveryone.utility.DBUtil;
/**
 * Created by plame_000 on 21-Oct-17.
 */

public class DBOperations extends SQLiteOpenHelper {

    private static final String DB_NAME = "JavaForEveryone.db";
    private static DBOperations sInstance = null;
    private static final int DB_VERSION = 1;

    private static final String ACHIEVEMENTS_QUERY = "create table "
            + DBUtil.Achievements.TABLE_NAME + "("
            + DBUtil.Achievements.ID + " integer primary key,"
            + DBUtil.Achievements.TITLE + " text,"
            + DBUtil.Achievements.DESC + " text,"
            + DBUtil.Achievements.PTS + " integer);";

    private static final String SUBSTAGES_QUERY = "create table "
            + DBUtil.Substage.TABLE_NAME + "("
            + DBUtil.Substage.ID + " integer primary key,"
            + DBUtil.Substage.TITLE + " text,"
            + DBUtil.Substage.QUESTION + " text,"
            + DBUtil.Substage.TEXT + " text,"
            + DBUtil.Substage.TRUE_ANSWER + " integer);";

    private static final String STAGES_QUERY = "create table "
            + DBUtil.Stage.TABLE_NAME + "("
            + DBUtil.Stage.ID + " integer primary key,"
            + DBUtil.Stage.TITLE + " text,"
            + DBUtil.Stage.QUESTIONS + " text,"
            + DBUtil.Stage.TRUE_ANSWERS + " text);";

    private static final String FINAL_TEST_QUERY = "create table "
            + DBUtil.FinalTest.TABLE_NAME + "("
            + DBUtil.FinalTest.ID + " integer primary key,"
            + DBUtil.FinalTest.QUESTIONS + " text,"
            + DBUtil.FinalTest.TRUE_ANSWERS + " text);";


    private DBOperations(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }
    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL("PRAGMA foreign_keys=ON");
        db.execSQL(ACHIEVEMENTS_QUERY);
        db.execSQL(SUBSTAGES_QUERY);
        db.execSQL(STAGES_QUERY);
        db.execSQL(FINAL_TEST_QUERY);
        insertQueries(db);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }

    public static DBOperations getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new DBOperations(context.getApplicationContext());
        }
        String wtf = "";
        return sInstance;

   }

    private void insertQueries(SQLiteDatabase db) {

        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'Първи взет тест','При първи успешен тест', 10)");
        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'ИТ талант','При взет финален тест без грешка', 100)");
        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'Тест машина','При взет междинен тест без грешка', 10)");
        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'Почти се справи','При първи взет тест с по-малко от 100/100 точки (губиш правото за Achievement Изрод) :( ', 5)");
        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'Изрод','При взети всички междинни тестове без грешка', 25)");
        db.execSQL("insert into "+ DBUtil.Achievements.TABLE_NAME+" values(null, 'Най-голям провал','При междинен тест без верен отговор', -25)");

        db.execSQL("insert into "+ DBUtil.Stage.TABLE_NAME+" values(null, 'Въведение','Какво представлява един клас?,Можем ли да създадем два обекта от един клас?,Кое от следните е вярно твърдение?', 'Обекти от реалния свят,Само променливи,Само методи,Да,Не,Само когато изрично му посочим,Всеки обект има свойствата и функциите на класа,Обектите нямат общо със свойствата на класа,Обектът приема само константите на класа')");
        db.execSQL("insert into "+ DBUtil.Stage.TABLE_NAME+" values(null, 'О.О.П.','Можем ли да имаме private конструктор?,Кои от следните ключови думи са модификатори за достъп?,Какво е нужно за да има полиморфизъм?', 'Да,Не,Само в private клас,public private protected default,public private protected static,public private final abstract,само override,само overload,override и overload')");
        db.execSQL("insert into "+ DBUtil.Stage.TABLE_NAME+" values(null, 'Колекции','Каква е разликата между ArrayList и масив?,Каква колекция бихте избрали за влакова композиция?,Каква е сложността на достъп до средния елемент в LinkedList?', 'Масивът е с фиксирана дължина,ArrayList е с фиксирана дължина,Нямат разлика,LinkedList,Масив,HashMap,Линейна,Константна,Логаритмична')");
        db.execSQL("insert into "+ DBUtil.Stage.TABLE_NAME+" values(null, 'Обхождане','С помощта на кое от следните обхождаме Map?,Кои от следните методи са задължителни за обхождане на колекция с Iterator?,Можем ли да променим стойност в колекция чрез Foreach?', 'Entry,Object,ArrayList,next() и hasNext(),previous() и next(),continue() и get(),Не,Да,Само в Map')");
        db.execSQL("insert into "+ DBUtil.Stage.TABLE_NAME+" values(null, 'Вътрешни Класове','Можем ли да имаме вътрешен статичен клас?,Engine е вътрешен нестатичен клас в класа Car. Можем ли да създадем обект Engine без да имаме обект Car? ,Можем ли да преизползваме референция от анонимен клас?', 'Да,Не,Само ако и външния е статичен,Не,Да,Само във външния клас може да се създаде отбект от вътрешния,От анонимен клас няма референция,Да,Не')");

        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Класове','<p align=\"center\"><strong>Какво е Клас?</strong></p>\n<p align=\"center\">Клас(class) &ndash; наричаме описание на даден обект.<br /> Класът представлява шаблон, който описва видовете<br /> състояния и поведение на обектите(екземплярите)<br /> които биват създадени от този клас (шаблон).</p>\n<p align=\"center\">&nbsp;</p>\n<p align=\"center\"><strong>Какво съдържа един клас?</strong></p>\n<p align=\"center\">Класът съдържа дефиниция на това какви данни трябва<br /> да се съдържат в един обект, за да се опише<br /> състоянието му.Обектът(Конкретния екземпляр от класа)<br /> съдържа самите данни.<br /> Тези данни дефинират състоянието му.<br /> Освен състояние, в класа също описваме и поведението<br /> на нашите обекти. То се изразява в действията които<br /> обектите ни могат да извършват.<br /> Средството на ООП, чрез което можем да описваме<br /> поведението на обектите от даден клас е<br /> деклариране на методи в класа.</p>\n<p align=\"center\">&nbsp;</p>\n<p align=\"center\"><strong>Елементи на Класа.</strong></p>\n<p align=\"center\">Сега ще изброим основните елементи на един клас,<br /> а по- късно ще разгледаме подробно всеки един.<br /> 1.Декларация на класа(class declaration)<br /> -Tова е реда на който декларираме името на класа<br /> Пример:</p>\n<p style=\"text-align: left;\" align=\"center\">______________________________________________________________________</p>\n<blockquote>\n<p><span style=\"color: #ff0000;\">public</span> <span style=\"color: #ff0000;\">class</span> Dog{}</p>\n</blockquote>\n<p>______________________________________________________________________</p>\n<p align=\"center\">2.Тяло на клас.<br /> -По подобие на методите, класовете също имат част<br /> която следва декларацията им, оградена с фигурни скоби.<br /> Между които се съдържа съдържанието на класа.<br /> Това се нарича тяло на класа. Елементите са изборени<br /> по надоло<br /> Пример:</p>\n<p>______________________________________________________________________</p>\n<p align=\"center\">&nbsp;</p>\n<blockquote>\n<p><span style=\"color: #ff0000;\">public</span> <span style=\"color: #ff0000;\">class</span> Dog{</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Тук ще бъде тялото на класа</p>\n<p>}</p>\n</blockquote>\n<p>______________________________________________________________________</p>\n<p>&nbsp;</p>\n<p align=\"center\">В тялото на класа можем да въведем полета които<br /> ще описват характеристиките (Полетата) и<br /> действията(Методите) на даден обект.</p>','Какво е Клас?', 'Шаблон за създаване на обекти')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Обекти','<p style=\"text-align: center;\"><strong>Какво е Обект?</strong></p>\n<p style=\"text-align: center;\" align=\"center\">Обект(object) &ndash; наричаме ексемпляр създаден по<br /> дефиницията(описанието) на даден клас.<br /> Когато един обект е създаден по описанието,<br /> което един клас дефинира, казваме, че обектът е<br /> от тип &bdquo;Името на този клас&rdquo;.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Още..?</strong></p>\n <p style=\"text-align: center;\" align=\"center\">Софтуерните обекти моделират обекти от<br /> реалния свят или абстрактни концепции<br /> (които също разглеждаме като обекти).<br /> Примери за реални обекти могат да бъдат<br /> хора, коли, стоки и т.н. Доколкото<br /> абстрактните обекти са понятия в предметна<br /> област които се налага да моделираме и<br /> използваме в компютърна програма.<br /> Примери за това са структурите от данни<br /> списъци, дърво и т.н.<br /> Те не са предмет на настоящата тема, но<br /> ще бъдат разгледани по напред в приложението.<br /> В обектите от реалния свят, а и в абстрактните<br /> могат да се отделят следните две групи<br /> характеристики:</p>\n<p style=\"text-align: center;\" align=\"center\"><br /> - Състояния (<strong>states</strong>)<br /> -Това са характеристики на обекта, които го<br /> определят и описват по принцип или в конкретен момент.</p>\n<p style=\"text-align: center;\" align=\"center\">Поведения(<strong>behavior</strong>)<br /> - Това са специфични характерни действия, които<br /> обектът може да извършва.</p>\n<p style=\"text-align: center;\" align=\"center\">Нека за пример вземем обектът от реалния свят<br /> &bdquo; Къче&rdquo;. Състоянията на кучето могат да бъдат<br /> &bdquo;име&rdquo;,&rdquo;порода&rdquo;,&rdquo;години&rdquo; а неговите поведения<br /> -&bdquo;издаване на звук&rdquo;,&rdquo;седене&rdquo;,&rdquo;тичане&rdquo;.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Как създаваме обект?</strong></p>\n<p style=\"text-align: center;\" align=\"center\">За да можем да използваме някой клас,<br /> първо трябва да създадем обект от него.<br /> За целта използваме ключовата дума <span style=\"color: #ff0000;\">new</span><br /> в комбинация с някой от <em>конструкторите</em>*<br /> на класа. Това ще създаде обект от дадения клас.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Пример за Обект.</strong></p>\n<p style=\"text-align: center;\" align=\"center\"><span style=\"color: #ff0000;\">public class</span> Cat{<br /> //тук въвеждаме<br /> //състояния и характеристики<br /> }</p>\n<p style=\"text-align: center;\" align=\"center\">Cat miau = <span style=\"color: #ff0000;\">new</span> Cat(<span style=\"color: #0000ff;\">String</span> name, Int age);</p>\n<p style=\"text-align: center;\" align=\"center\">*<em>конструктор &ndash; </em>За тях ще говорим малко<br /> по напред в приложението.</p>\n<p style=\"text-align: center;\" align=\"center\">&nbsp;</p>','Какво е Обект', 'Представител на точно един клас.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Капсулация','<p style=\"text-align: center;\"><strong>Принципи на ООП</strong></p>\n<p style=\"text-align: center;\" align=\"center\">Обектно Ориентираното Програмиране се състои от<br /> 4 принципа, които са както следва:<br /> - Капсулация<br /> - Наследяване<br /> - Абстракция<br /> - Полиморфизъм</p>\n<p style=\"text-align: center;\" align=\"center\">Като ще започнем разглеждането от - Капсулация</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Капсулация</strong></p>\n<p style=\"text-align: center;\" align=\"center\">Капсулацията можем да я разгледаме като<br /> ограничаване на достъпа до характеристиките и<br /> поведението на нашия обект, така че във външния<br /> свят да се вижда или оперира само с тези атрибути<br /> които не биха повлияли правилното поведение<br /> на нашия обект.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Реализация</strong></p>\n<p style=\"text-align: center;\" align=\"center\">Капсулацията се реализира благодарение<br /> на модификатори за достъп:</p>\n<p style=\"text-align: center;\" align=\"center\"><span style=\"color: #ff0000;\">private</span><br /> -Прави полето/метода видим само за класа.</p>\n<p style=\"text-align: center;\" align=\"center\"><span style=\"color: #ff0000;\">default</span><br /> -видими за вскички класове в пакета.</p>\n<p style=\"text-align: center;\" align=\"center\"><span style=\"color: #ff0000;\">protected</span><br /> -видим за всички класове в пакета,<br /> също и наследниците на класа в<br /> проекта.</p>\n<p style=\"text-align: center;\" align=\"center\"><span style=\"color: #ff0000;\">public</span><br /> -видим за всички в проекта.</p>\n<p style=\"text-align: center;\" align=\"center\">Пример:</p>\n<p style=\"text-align: center;\"><span style=\"color: #ff0000;\">public class</span> Dog{</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color: #ff0000;\">private</span> <span style=\"color: #0000ff;\">String</span> name;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color: #ff0000;\">private</span> int age;</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\" align=\"center\">Това прави променливите &ndash; name и age, видими<br /> само за класа Dog.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Хммм, Ами сега?!<br /> </strong><strong>Setter/Getter</strong></p>\n<p style=\"text-align: center;\" align=\"center\">След като сме ограничили достъпа до името и годините<br /> на нашето куче това създава известен проблем, а именно,<br /> как бихме научили на колко години е кучето, ако работим<br /> с него от друг клас, след като полето е заключено..?<br /> На помощ ни идват така наречените Getter-и, <br /> това представляват методи които ни връщат стойността<br /> на дадено поле като в самия метод може да<br /> имплементираме логика за запазване на данните.</p>\n<p style=\"text-align: center;\"><span style=\"color: #ff0000;\">protected</span> <span style=\"color: #0000ff;\">String</span> getName(){</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color: #ff0000;\">return</span> name;</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\" align=\"center\">След като си решихме проблема с виждането<br /> на променливите идва следващия проблем в който<br /> нашето животно не би могло да порасне, тъй като<br /> ние можем да видим годините му но не и да ги променим<br /> С помощта на Setter-и ние бихме могли да променим стойноста<br /> на годините и да вкараме логика за да не се променят<br /> годините със неадекватна стойност която би счупила<br /> нашето приложение. Представете си ако полето е<br /> byte а някой зададе стойност 300 за години на кучето.</p>\n<p style=\"text-align: center;\"><span style=\"color: #ff0000;\">protected</span> <span style=\"color: #000000;\">int </span>setAge(int newAge){</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"color: #ff0000;\">if</span>(newAge &lt; age || newAge &nbsp;&gt; 1){</p>\n<p style=\"text-align: center;\"><span style=\"color: #ff0000;\">return</span>;</p>\n<p style=\"text-align: center;\">}<span style=\"color: #ff0000;\">else</span>{</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age = newAge;</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\" align=\"center\">Така вече ограничаваме въвеждането на нови<br /> години за кучето, като то може да приема стойност<br /> само с 1 повече от сегашната стойност.</p>\n<p style=\"text-align: center;\">&nbsp;</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Ключова дума &ndash; </strong><strong><span style=\"color: #ff0000;\">Static</span><br /> </strong>Ключовата дума static използвана с променлива<br /> би направила въпросната &ndash; обща за всички обекти<br /> създадени от този клас.<br /> Тоест, ако променливата ни age по горе е статична<br /> то всички кучета ще са на една възраст ВИНАГИ.<br /> Същото важи за статичните методи.<br /> Още: Статичните атрибути, могат да се достъпват<br /> дори и да не сме създали обект от даден клас.<br /> Защото те са променливи на класа а не на конкретен обект.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Ключова дума &ndash; </strong><strong><span style=\"color: #ff0000;\">Final</span><br /> </strong>С нея указваме, че дадено поле няма да бъде променяно<br /> до края на нашата програма.<br /> Тоест, ако нашата променлива name е final, и <br /> зададем име &ndash; Пухчо, кучето ни ще остане с<br /> име Пухчо до края на програмата, и не бихме<br /> Могли да го променим по никакъв начин.<br /> <br /> Ако една променлива е едновременно<br /> <span style=\"color: #ff0000;\">static final</span> &ndash; това я прави константа!</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Какво е Конструктор*?<br /> </strong>Той се използва при създаване на обект, като<br /> можем да кажем, че той приема някакви входни данни<br /> или да оставим default конструктор който не приема<br /> данни.<br /> Пример:</p>\n<p style=\"text-align: center;\"><span style=\"color: #ff0000;\">public &nbsp;class</span> Dog{</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Променливите по горе<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dog(<span style=\"color: #0000ff;\">String</span> dogName, int dogAge){</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name = dogName;</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; age = dogAge;</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\">}</p>\n<p style=\"text-align: center;\">Dog fluffy = <span style=\"color: #ff0000;\">new</span> Dog(&bdquo;Балкан&rdquo;, 5);</p>\n<p style=\"text-align: center;\" align=\"center\">Така създаваме куче с името &ndash; &bdquo;Балкан&rdquo; което е<br /> на 5 години. Така още при създаването на обект<br /> можем да изнесем логика и контрол относно данните<br /> с които нашият обект бива създаден.</p>\n<p style=\"text-align: center;\" align=\"center\">&nbsp;</p>','До кое има достъпн ключовата дума : protected?', 'До пакета и наследниците в проекта.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Наследяване','<p style=\"text-align: center;\" align=\"center\"><strong>Наследяване</strong></p>\n<p style=\"text-align: center;\" align=\"center\">Наследяването е принцип, при който ако един обект<br /> Пр.: Куче, съдържа всички свойства и действия на<br /> друг обект пр.: Животно, следователно<br /> Кучето може да наследи Животно.<br /> По този начин то приема освен своите атрибути<br /> така и тези на наследения клас &ndash; родителя си,<br /> а именно на Животно. По този начин се избягва<br /> повторното дефиниране и се създава<br /> възможност за прилагане на йерархии<br /> от класове. Така ако всяко животно<br /> си има име и години. Нашето куче може да го<br /> наследи и да приеме автоматично тези полета.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Връзки!?!</strong></p>\n<p style=\"text-align: center;\" align=\"center\">В наследяването се наблюдават 2 типа връзки.</p>\n<ol style=\"text-align: center;\">\n<li>Has A (Има)<br /> -Наричаме &bdquo;Композиция&rdquo;</li>\n<li>Is a (Е)<br /> - Наричаме &bdquo;Наследяване&rdquo;</li>\n</ol>\n<p style=\"text-align: center;\" align=\"center\">Тези връзки се изобразяват най &ndash; лесно като</p>\n<p style=\"text-align: center;\" align=\"center\">си представим структурата от класове<br /> Къща, Баня и Сграда.<br /> Разбираме кога имаме (HAS A) връзка като си<br /> зададем въпроса &bdquo;Клас1 ИМА ли Клас2&rdquo; в пример:<br /> Баня ИМА ли Сграда &ndash; НЕ<br /> Сграда ИМА ли Къща &ndash; НЕ<br /> Къща ИМА ли Баня &ndash; ДА <br /> При положителен резултат реализираме (HAS A)<br /> връзка, а тя се осъществява като в клас1(Къща)<br /> добавим поле от тип клас2(Баня)</p>\n<p style=\"text-align: center;\" align=\"center\">class House{</p>\n<p style=\"text-align: center;\" align=\"center\">private Bathroom bath;</p>\n<p style=\"text-align: center;\" align=\"center\">}</p>\n<p style=\"text-align: center;\" align=\"center\">При (IS A) задаваме въпроса<br /> &bdquo;Клас1, клас2 ли Е?&rdquo; в пример:<br /> Къща, Баня ли Е &ndash; НЕ<br /> Сграда, Баня ли Е &ndash; НЕ<br /> Къща, Сграда ли е &ndash; ДА</p>\n<p style=\"text-align: center;\" align=\"center\">Положителния резултат реализираме наследяване<br /> като използваме ключовата дума extends<br /> class House extends Building{</p>\n<p style=\"text-align: center;\" align=\"center\">private Bathroom bath;</p>\n<p style=\"text-align: center;\" align=\"center\">}</p>\n<p style=\"text-align: center;\" align=\"center\">&nbsp;</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Ключови думи &ndash; </strong><strong>super и </strong><strong>this.</strong></p>\n<p style=\"text-align: center;\" align=\"center\">this, с нея достъпваме променливи от текущия клас.<br /> Така се улесняваме да разберем дали променливата<br /> е поле на класа или външна такава.<br /> Пример при Setter</p>\n<p style=\"text-align: center;\" align=\"center\">protected void setAge(int age){</p>\n<p style=\"text-align: center;\" align=\"center\">this.age = age;</p>\n<p style=\"text-align: center;\" align=\"center\">}</p>\n<p style=\"text-align: center;\" align=\"center\">Въпреки че и външната променлива също е наречена<br /> age, ние указваме че годините на класа(this.age)<br /> са равни на външните години.</p>\n<p style=\"text-align: center;\" align=\"center\">Ключовата дума super, работи на подобен принцип,<br /> но тя дава достъп до методи и променливи<br /> на родителския клас. Тоест ако класа ни куче<br /> наследява животно той няма да има своя променлива<br /> age, а тялото на setAge в Куче би изглеждало така<br /> super.age = age;</p>\n<p style=\"text-align: center;\" align=\"center\">&nbsp;</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>Допълнение.<br /> </strong>Важно е да знаем че един клас може да наследява<br /> само един клас, но един клас може да бъде наследен<br /> от много класове. Тоест класа ни Куче може да наследи<br /> само Животно, но Животно може да бъде наследено<br /> от Къче, Котка, Папагал, Сом и т.н.</p>\n<p style=\"text-align: center;\" align=\"center\"><strong>!Teaser!<br /> </strong>Какво би станало ако в класа животно имаме метод<br /> който кара нашите обекти да издават звук<br /> makeNoise(), и обектите куче и котка наследят животно?<br /> Те биха издавали звук по един и същ начин.<br /> Това е проблем...<br /> Как бихме могли да преустановим това и всяко<br /> животно да издава свой собствен звук въпреки<br /> че родителкият клас е един.</p>','Колко класа може да наследи един клас?', 'Само един.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Абстракция','<p align=\"center\"><strong>Абстракция</strong></p>\n<p align=\"center\">Какво представлява абстракцията?<br /> Това е абстрактна идея на това как бихме искали да изглежда<br /> нашият обект или с други думи представяне на най &ndash; важната<br /> функционалност на света, без той да се интересува как<br /> нашият обект работи от вътре.<br /> Пример: Дистанционно<br /> Всеки от нас е виждал дистанционно но малко от нас<br /> знаят как работи то. Знаем за част от неговата<br /> функционалност, да смени канал, да увеличи или намали<br /> звука и т.н. и друго не ни интересува!</p>\n<p align=\"center\">&nbsp;</p>\n<p align=\"center\"><strong>Реализация</strong></p>\n<p align=\"center\">Абстракция може да се реализира по два начина</p>\n<ol>\n<li style=\"text-align: center;\">Чрез Абстрактен Клас.</li>\n<li style=\"text-align: center;\">Чрез Интерфейс.</li>\n</ol>\n<p align=\"center\">Ще започнем отзад напред поради това, че въвеждаме<br /> нов термин &ndash; Интерфейс.<br /> Какво е интерфейс?<br /> Това е дефиниция за обект, като ние задължаваме<br /> всеки един обект имплементиращ нашият интерфейс<br /> да има неговата функционалност.<br /> Тоест ако имаме интерфейс &ndash; &ldquo;Explodable&rdquo; който<br /> ще описва взривни устройства и съдържа 2 функции<br /> взриви и обезвреди.<br /> Ако след това имаме обект &bdquo; Граната&rdquo; който имплементира<br /> нашият интерфейс, то този обект ще трябва да има<br /> и двата метода които идват от въпросния интерфейс.</p>\n<p align=\"center\">Методите/Функциите в интерфейс се създават без тяло,<br /> като това задължава всеки клас имплементиращ интерфейса<br /> да пренапише неговите функционалности по<br /> адекватен за тях начин.</p>\n<p align=\"center\">По дефиниция всички променливи в интерфейс<br /> са константи, тоест ако просто напишем<br /> int x = 5;<br /> вътрешно това би представлявало<br /> public static final int x = 5;<br /> Поради този факт в интерфейс имената на променливите<br /> се записват по приетия начин за записване на константи<br /> а именно с главни букви и _ при нужда от<br /> словосъчетания.<br /> Пример:<br /> int THIS_IS_CONSTANT = 5;</p>\n<p align=\"center\">Модификатори за достъп в интерфейс.<br /> По подразбиране всички полета и функции в интерфейс<br /> са с public модификатор за достъп.<br /> Прието е, че наименоването на интерфейс е както следва</p>\n<p align=\"center\">-Ако е възможно добавяме &bdquo;-able&rdquo; след думата, както беше<br /> нашият пример &ndash; ExplodABLE, ако това не е възможно,<br /> просто добавяме &bdquo; I &ldquo; пред името<br /> Пример:<br /> interface IRobot{</p>\n<p align=\"center\">//функции на интерфейс</p>\n<p align=\"center\">}</p>\n<p align=\"center\">Имплементирането на интерфейс се<br /> осъществява чрез ключовата дума<br /> implements<br /> Пример:<br /> class Granade implements Expodable{</p>\n<p align=\"center\">//тяло на класа</p>\n<p align=\"center\">}</p>\n<p align=\"center\">След като знаем какво е клас, лесно можем да дадем<br /> дефиниция за абстрактен такъв.<br /> Абстрактен Клас, можем да наречем незавършен клас,<br /> или клас който не може да определи адекватно<br /> решение за даден метод. Спомнете си примера<br /> с метода makeNoise() в класа Животно.<br /> Така лесно можем да направим нашият клас<br /> Животно абстрактен и да оставим въпросния метод<br /> без тяло, което ще задължи всички наследници<br /> да пренапишат този метод.<br /> Абстрактен клас се създава с ключовата дума<br /> abstract<br /> Пример:<br /> abstract class Animal{</p>\n<p align=\"center\">protected void makeNoise();</p>\n<p align=\"center\">}</p>\n<p align=\"center\">Това е нашият абстрактен клас животно, който има<br /> недовършен метод. Ако наследника също не може<br /> да измисли адекватно решение за метода<br /> той също може да стане абстрактен. Като<br /> оставя написването на метода за други<br /> дъщерни класове.</p>\n<p align=\"center\">След като разбрахме, че абстрактен клас и <br /> интерфейс си приличат. Как да изберем кое да ползваме.<br /> Не забравяйте, че един клас може да наследи само един.<br /> Доколкото един клас, може да имплементира неопределен<br /> брой интерфейс.<br /> Още &ndash; в Интерфейс, променливите са константи<br /> доколкото в Абстрактен Клас &ndash; не.</p>','Какво е Абстракция?', 'Представяне на най- важната функционалност.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Полиморфизъм','<p align=\"center\"><strong>Полиморфизъм</strong></p>\n<p align=\"center\">Това е възможността на един обект да приема много форми.<br /> Полиморфизъм се осъществява само чрез<br /> Наследяване/Имплементация И Override на метод!<br /> За да добиете по чиста представа за полиморфизъм<br /> ще се отдадем на примери с обяснения.</p>\n<p align=\"center\">Нека приемем, че имаме абстрактен клас котка<br /> който наследява животно и има неизпълнен метод<br /> makeNoise();</p>\n<blockquote>\n<p>abstract class Cat extends Animal{</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void makeNoise();</p>\n<p>}</p>\n</blockquote>\n<p align=\"center\">След което имаме 2 класа които наследяват<br /> класа котка<br /> Тигър и Сиамска котка.</p>\n<blockquote>\n<p>class Tiger extends Cat{</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void makeNoise(){</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&ldquo;Roarrr&rdquo;);</p>\n<p>}</p>\n<p>}</p>\n<p>class Siamese extends Cat{</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void makeNoise(){</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&ldquo;Miauuu&rdquo;);</p>\n<p>}</p>\n<p>}</p>\n</blockquote>\n<p align=\"center\">Сега можем да представим Полиморфизма в<br /> нашето демо и метода main.</p>\n<blockquote>\n<p>public static void main(String[] args){</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cat poly&rsquo;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poly = new Tiger();</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poly.makeNoise();</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poly = new Siamese();</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; poly.makeNoise();</p>\n<p>}</p>\n<p>Console<br /> Roarrr<br /> Miauuu</p>\n</blockquote>\n<p align=\"center\">Въпреки, че poly е референция от клас котка тя може<br /> да се държи по различен начин ако бъде<br /> пренасочена към дъщерен клас тоест<br /> тигър или сиамска котка.<br /> Това поражда понятието полиморфизъм.<br /> Същото можем да изобразим с интерфейс<br /> Пример:<br /> Explodable и различни взривни устройства.</p>\n<p align=\"center\">Сега е момента в който ще отделим време за да<br /> разясним какво е Override и Overload</p>\n<p align=\"center\"><strong>Override<br /> </strong>Когато в родителски клас има метод който искаме<br /> да реагира по различен начин ако бъде извикан от<br /> сегашния клас ние трябва да го пренапишем<br /> това и представлява Override.<br /> В различни класове един и същ метод да функционира<br /> по адекватен за ситуацията начин.<br /> При пренаписването на родителски метод над самия<br /> метод се записва анотация, която да ни уведоми, че този<br /> метод е пренаписан от по &ndash; горен клас<br /> - @Override</p>\n<p align=\"center\"><strong>Overload<br /> </strong>Имаме Overload когато в даден клас създадем метод<br /> с еднакво име, но различни приемани аргументи.</p>','Какво е задължително за да \n имаме Полиморфизъм?', 'Наследяване или Имплементация и Override.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Лист','<p style=\"text-align: center;\" align=\"center\"><strong>Колекции</strong> </p>\n<p style=\"text-align: center;\">В Java &nbsp;се тазличават няколко групи структури от данни,</p>\n<p style=\"text-align: center;\">върху които се изграждат колекциите:</p>\n<p style=\"text-align: center;\">-Линейни &ndash; към тях спадат List-овете</p>\n<p style=\"text-align: center;\">-Дървовидни &ndash; различните типове дървета</p>\n<p style=\"text-align: center;\">-Речници &ndash; на базата на ключ-стойност</p>\n<p style=\"text-align: center;\">-Множества &ndash; към тях спадат Set-овете</p>\n<p style=\"text-align: center;\"><strong>Линейни структури от данни.</strong></p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp; ArrayList &ndash; предимствата му пред обикновения масив е,<br />че не е с фиксирана дължина и може да<br />съдържа в себе си различни типове данни.<br />Достъпът до всеки елемент е с константа сложност.<br />Добавянето на елемент в края също е с константна сложност,<br />докато добавянето в средата<br />също само по себе си е константно,<br />но изместването на останалите елементи е линейно.</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp; LinkedList &ndash; свързан списък. <br />Всеки елемент в него знае само и единствено за елемента след и преди него.<br />Добавянето на елементи в началото и края е константно.<br />Самото добавяне в средата също е константно,<br />но достигането до елемента е линейно.</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp; Stack &ndash; стек. Принципа е &bdquo;последния влязъл, първи излиза&ldquo; (LIFO).</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp; Queue &ndash; опашка. Принципа е &bdquo;първия влязъл, първи излиза&ldquo; (LIFO).</p>\n<p style=\"text-align: center;\">&nbsp;</p>','Каква е сложността на достъп до елемент в ArrayList', 'Константа.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Сет','<p style=\"text-align: center;\"><strong>Set</strong></p>\n<p style=\"text-align: center;\">Иизграден на базата на хеш таблицата.<br />Съхранява обектите в себе си като им вземе hashCode()<br /> и го рездели модулно на броя клетки на таблицата.<br />След това проверява с equals()<br />дали вече няма вкаран<br />същия обект и ако няма го вкарва.<br />Ако има друг обект в тази клетка,<br />то той се добавя до него като свързан списък.<br />Създадените класове в Java на <br />базата на множествата са HashSet и TreeSet.<br />Разликата между тях е,<br />че обектите които се съхраняват в<br />TreeSet са подредени в т.нар. Natural order.</p>','Каква е сложността на добавяне в TreeSet', 'Логаритмична')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Мап','<p style=\"text-align: center;\"><strong>Map</strong></p>\n<p style=\"text-align: center;\">Изграден на базата на структурата от данни речник.<br />Речниците са на база ключ &ndash; стойност.<br />Ключовете са уникални.<br />Всеки ключ с неговата стойност образуват<br />т.нар. ентри (entry).<br />Класовете, които имплементират този интерфейс са:<br />HashMap и TreeMap.<br />Разликата между тях е,<br />че ключовете които се<br />съхраняват в TreeMap са<br />подредени в т.нар. Natural order.</p>','Имаме ли достъп по индекс в Map', 'Не.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Iterator и Foreach','<p align=\"center\"><strong>Iterator.</strong></p>\n<p align=\"center\">Итераторът служи за обхождане на колекции.<br />Това е клас, който ни дава достъп до всеки елемент в колекцията.<br />Когато искаме да кажем на дадена колекция,<br />че ще бъде обхождана с итератор, извикваме метода .iterator()<br />и въртим колекцията до .hasNext(),<br />който ни казва дали има следващ елемент (true/false).<br />За отиване на следващ елемент се използва метода .next().<br />Следващия снипет показва обхождането на ArrayList:</p>\n<p align=\"center\">ArrayList list = new ArrayList();</p>\n<p align=\"center\">for(Iterator it = list.iterator() ; it.hasNext() ; ){</p>\n<p align=\"center\">Object obj = it.next();</p>\n<p align=\"center\">// do something with the object</p>\n<p align=\"center\">}</p>\n<p align=\"center\">&nbsp;</p>\n<p align=\"center\"><strong>Foreach.</strong></p>\n<p align=\"center\">Foreach е друг начин за обхождане на колекции.<br />Разликата му освен в синтаксиса е,<br /> че с foreach НЕ може да се променят обектите в колекцията.<br />Това означава, че могат да бъдат само четени.<br />Ако се опитаме да променим даден елемент от колекцията,<br />компилаторът няма да даде грешка,<br />но промяната няма да се случи.<br />Следващия снипет покзва обхождане на колекция с foreach:</p>\n<p align=\"center\">ArrayList&lt;Integer&gt; nums = new ArrayList();</p>\n<p align=\"center\">nums.add(1);</p>\n<p align=\"center\">nums.add(2);</p>\n<p align=\"center\">foreach(Integer num : nums){</p>\n<p align=\"center\">num += 2;</p>\n<p align=\"center\">}</p>\n<p align=\"center\">System.out.println(nums);</p>\n<p align=\"center\">// print: 1 , 2</p>\n<p align=\"center\">&nbsp;</p>','Основна разлика между Iterator и Foreach', 'Iterator - чете и пише, Foreach - само чете')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Comparator vs. Comparable','<p style=\"text-align: center;\">В Java има два начина за сравняване на обекти.</p>\n<p style=\"text-align: center;\"><strong>Comparable</strong><strong> (java.lang.Comparable).</strong></p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Изисква пренаписването на метода compareTo(Object o1), който връща:</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1 ако о1 &gt; this</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ако о1 == this</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 ако o1 &lt; this</p>\n<p style=\"text-align: center;\">Пример:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public abstract class Car implements Comparable&lt;Car&gt;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public abstract int getMaxSpeed();</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public int compareTo(Car otherCar)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(this.getMaxSpeed() &gt; otherCar.getMaxSpeed())</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(this.getMaxSpeed() &lt; otherCar.getMaxSpeed())</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong>&nbsp;</strong></p>\n<p style=\"text-align: center;\"><strong>Comparator (java.util.Comparator)</strong></p>\n<p style=\"text-align: center;\"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong>Изисква пренаписването на compare(Object o1, Object o2), който връща:</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 ако о1 &gt; о2</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 ако о1 == о2</p>\n<p style=\"text-align: center;\">-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1 ако о1 &lt; о2</p>\n<p style=\"text-align: center;\">Пример:</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public class CarComparator implements Comparator&lt;Car&gt;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @Override</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Public int compare(Car car1, Car car2)</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(car1.getMaxSpeed() &gt; car2.getMaxSpeed())</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if(car1.getMaxSpeed() &lt; car2.getMaxSpeed())</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>','Можем ли едновременно да се възползваме\nот функционалността и на двете.', 'Да.')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Wrapper Classes','<p style=\"text-align: center;\"><strong>Обвиващи Класове</strong></p>\n<p style=\"text-align: center;\"><br />В Java всеки от примитивните типове данни<br />си има своя т.нар. wrapper class (обект от този тип).<br />Wrapper класовете са: <br />Boolean, Character, Byte, Short, Integer, Long, Float, Double.</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Autoboxing е процес, в който примитивните типове автоматично<br />се &bdquo;преобразуват&ldquo; в еквивалентния си wrapper клас.</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Auto-unboxing е процес,<br />в който стойността от wrapper класа<br />автоматично се преобразува в<br />еквивалентния си примитивен тип.</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Пример:</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; List&lt;Integer&gt; myList = new ArrayList&lt;Integer&gt;();</p>\n<p style=\"text-align: center;\">myList.add(47); // legal: 47 is automatically boxed</p>\n<p style=\"text-align: center;\">int a = myList.get(0); // legal: a is automatically unboxed</p>','Какво би изписал следния пример\nint a = 3;\nInteger b = 3;\nSystem.out.print(a.equals(b));', 'Компилационна грешка')");
        db.execSQL("insert into "+ DBUtil.Substage.TABLE_NAME+" values(null, 'Вложени и Анонимни','<p style=\"text-align: center;\"><strong>Вложени и Анонимни</strong></p>\n<p style=\"text-align: center;\">Вложените класове биват два вида:</p>\n<p style=\"text-align: center;\">-статични вложени класове <br />&ndash; използват се когато искаме вътрешния клас<br />да е независим от външния.<br />С тях единствено спестяваме .java файла.<br />Например ако static class Engine<br />е вътрешен клас на class Car, <br />то може да създадем в демото: <br />Engine engine = new Engine().</p>\n<p style=\"text-align: center;\">Ако дефинираме вътрешния клас със static private,<br />то така обявяваме,<br />че обект от вътрешния клас може да създава само външния клас.<br />Например ако static private class Engine е вътрешен клас на class Car,<br />то само Car може да създаде обект от тип Engine.<br />Пример в демото:<br />Car.Engine engine = new Car.Engine();</p>\n<p style=\"text-align: center;\">Вътрешния статичен клас има достъп до всички<br />статични променливи на външния клас, дори и ако те са private.<br />Но ако те не са статични, а само private,<br />то тогава вътрешния клас не може да ги достъпва.</p>\n<p style=\"text-align: center;\">- нестатични (inner) класове &ndash; <br />използват се когато не искаме да създаваме един обект<br />без съществуването на друг обект.<br />Например искаме да създадем обект от тип мозък.<br />Само че мозъкът не може да съществува без човек<br />и за това правим класът мозък вътрешен (inner) за класа човек.<br />Имплементация в демото:</p>\n<p style=\"text-align: center;\">Person p = new Person();</p>\n<p style=\"text-align: center;\">Brain brain = p.new Brain();</p>\n<p style=\"text-align: center;\">Анонимни класове:</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &bdquo;Анонимните&ldquo; класове са специален вид локални класове.<br />Специалното при тях е, че те нямат специални имена<br />и на тях винаги правим само една инстанция.<br />Използваме ги ако имаме нужда само от<br />един обект само на едно място. Пример:</p>\n<p style=\"text-align: center;\"><strong>abstract</strong>&nbsp;<strong>class</strong>&nbsp;Person{&nbsp;&nbsp;</p>\n<p style=\"text-align: center;\">&nbsp;&nbsp;<strong>abstract</strong>&nbsp;<strong>void</strong>&nbsp;eat();&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br /><strong>class</strong>&nbsp;TestAnonymousInner{&nbsp;&nbsp;<br />&nbsp;<strong>public</strong>&nbsp;<strong>static</strong>&nbsp;<strong>void</strong>&nbsp;main(String&nbsp;args[]){&nbsp;&nbsp;<br />&nbsp;&nbsp;Person&nbsp;p=<strong>new</strong>&nbsp;Person(){&nbsp;&nbsp;<br />&nbsp;&nbsp;<strong>void</strong>&nbsp;eat(){System.out.println(\"nice&nbsp;fruits\");}&nbsp;&nbsp;<br />&nbsp;&nbsp;};&nbsp;&nbsp;<br />&nbsp;&nbsp;p.eat();&nbsp;&nbsp;<br />&nbsp; }&nbsp;&nbsp;<br />&nbsp;}&nbsp;&nbsp;</p>','Зависи ли статичния вътрешен клас от външния', 'Не.')");

        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Класът Dog наследява Animal.Ако създадем Dog колко обекта има в паметта?', '3,2,1')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли в LinkedList да вземем третия елемент?', 'Да,Не,Само с итератор')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Каква е разликата между структури от данни и колекции?', 'Колекциите са създадени на базата на структурите от данни,Структурите от данни са създадени на база на колекциите,Нямат разлика')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Какво е constructor chaining?', 'Извикване на конструктор в конструктор,Извикване на метод от конструктор,Създаване на обект в конструктор')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Каква е разликата между HashSet и HashMap?', 'HashMap - когато запазваме двойка елементи,HashSet - когато запазваме двойка елементи,В HashSet елементите са сортирани')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли да забраним на метод да бъде Override-нат?', 'Да - с ключовата дума final,Не,Само ако е static')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли да забраним на даден клас да бъде наследяван?', 'Да,Не,Само ако е вътрешен')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Кой от следните модификатори за достъп позволява достъп до целия пакет?', 'default,protected,public')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Кое от изброените е AutoBox?', 'От примитивен тип към референтен тип,От референтен тип към примитивен тип,Нито едното')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли да наследим String класа?', 'Не,Да,Само ако класът ни е вътрешен и статичен')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'С коя ключова дума забраняваме промяната на дадена променлива?', 'final,static,private')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Как се достъпва статично поле/метод?', 'С името на класа,Чрез Object класа,Статични полета и методи не могат да бъдат достъпени')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Как правим една променлива константа?', 'public static final,public static,public final')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли в конструктор да извикаме два конструктура?', 'Не,Да,Само ако са public')");
        db.execSQL("insert into "+ DBUtil.FinalTest.TABLE_NAME+" values(null, 'Можем ли да имаме public поле в метод?', 'Не,Да,Само ако е final')");
    }

    public ArrayList getSubstageInfo(String substageTitle){
        ArrayList<String> substageInfo = new ArrayList<String>();
        SQLiteDatabase db = this.getReadableDatabase();

        Cursor cursor = db.rawQuery("select * from Substages where Substages.title = '" + substageTitle + "'", null);
       
        if (cursor.getCount() < 1){
            substageInfo.add("EMPTY");
            cursor.close();
            return substageInfo;
        }
        cursor.moveToFirst();
        substageInfo.add(cursor.getString(cursor.getColumnIndex("text")));
        substageInfo.add(cursor.getString(cursor.getColumnIndex("question")));
        substageInfo.add(cursor.getString(cursor.getColumnIndex("answer")));
        cursor.close();
        db.close();
        return substageInfo;
    }

    public ArrayList getFinalTestInfo(){
        ArrayList<ArrayList<String>> finalTestInfo = new ArrayList<>();
        SQLiteDatabase db = this.getReadableDatabase();

        Cursor cursor = db.rawQuery("select * from FinalTest",null);
        int count = 0;
        while (cursor.moveToNext()){

            String question = cursor.getString(1);
            String[] answers = cursor.getString(2).split(",");

            finalTestInfo.add(new ArrayList<String>());
            finalTestInfo.get(count).add(question);
            finalTestInfo.get(count).add(answers[0]);
            finalTestInfo.get(count).add(answers[1]);
            finalTestInfo.get(count).add(answers[2]);

            count++;
        }

        return finalTestInfo;
    }

    public ArrayList getStageInfo(String stageTitle){
        ArrayList<ArrayList<String>> stageInfo = new ArrayList<>();
        SQLiteDatabase db = this.getReadableDatabase();

        Cursor cursor = db.rawQuery("select * from Stage where Stage.title = '" + stageTitle + "'",null);

        while(cursor.moveToNext()){
            String[] question = cursor.getString(2).split(",");
            String[] answers = cursor.getString(3).split(",");

            stageInfo.add(new ArrayList<String>());
            stageInfo.get(0).add(question[0]);
            stageInfo.get(0).add(answers[0]);
            stageInfo.get(0).add(answers[1]);
            stageInfo.get(0).add(answers[2]);

            stageInfo.add(new ArrayList<String>());
            stageInfo.get(1).add(question[1]);
            stageInfo.get(1).add(answers[3]);
            stageInfo.get(1).add(answers[4]);
            stageInfo.get(1).add(answers[5]);

            stageInfo.add(new ArrayList<String>());
            stageInfo.get(2).add(question[2]);
            stageInfo.get(2).add(answers[6]);
            stageInfo.get(2).add(answers[7]);
            stageInfo.get(2).add(answers[8]);
        }
        db.close();
        cursor.close();
        return stageInfo;

    }

    public ArrayList getAchievements(){
        SQLiteDatabase db = this.getReadableDatabase();
        ArrayList<ArrayList<Object>> achievements = new ArrayList<ArrayList<Object>>();

        Cursor cursor = db.rawQuery("select * from Achievements", null);

        if (cursor.getCount() < 1){
            achievements.add(new ArrayList<Object>());
            achievements.get(0).add("EMPTY");
            cursor.close();
            return achievements;
        }
        cursor.moveToFirst();
        String title = "";
        String desc = "";
        int pts;
        for (int i = 0; i < 6; i++) {
            title = cursor.getString(cursor.getColumnIndex("title"));
            desc = cursor.getString(cursor.getColumnIndex("desc"));
            pts = cursor.getInt(cursor.getColumnIndex("pts"));
            achievements.add(new ArrayList<Object>());
            achievements.get(i).add(title);
            achievements.get(i).add(desc);
            achievements.get(i).add(pts);
            cursor.moveToNext();
        }
        cursor.close();
        db.close();
        return achievements;
    }
}
